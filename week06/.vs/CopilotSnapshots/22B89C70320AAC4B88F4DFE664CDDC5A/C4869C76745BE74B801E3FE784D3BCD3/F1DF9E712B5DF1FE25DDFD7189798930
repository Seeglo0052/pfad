import pyaudio
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.animation as animation
import threading
import queue
import time

# Parameters
FORMAT = pyaudio.paInt16
CHANNELS = 1
RATE = 44100
CHUNK = 1024
ROLLING_WINDOW = 4 * RATE  # 4 seconds rolling window

class WaveformVisualizer:
    def __init__(self):
        # Initialize PyAudio
        self.p = pyaudio.PyAudio()
        self.audio_queue = queue.Queue(maxsize=100)
        self.buffer = np.zeros(ROLLING_WINDOW, dtype=np.int16)
        
        # Find and setup audio input
        self.setup_audio()
        
        # Setup matplotlib
        self.fig, self.ax = plt.subplots(figsize=(12, 6))
        self.x = np.arange(0, ROLLING_WINDOW) / RATE  # Convert to time in seconds
        self.line, = self.ax.plot(self.x, np.zeros(ROLLING_WINDOW), 'cyan', linewidth=0.8)
        
        self.ax.set_ylabel('Amplitude')
        self.ax.set_xlabel('Time (seconds)')
        self.ax.set_title('Real-time Audio Waveform')
        self.ax.set_ylim(-2**15, 2**15)  # 16-bit audio range
        self.ax.grid(True, alpha=0.3)
        
        plt.tight_layout()
        
    def setup_audio(self):
        """Find and setup audio input device"""
        # Find input device
        input_device = None
        print("Available audio devices:")
        for i in range(self.p.get_device_count()):
            device_info = self.p.get_device_info_by_index(i)
            if device_info['maxInputChannels'] > 0:
                print(f"  {i}: {device_info['name']}")
                if input_device is None:
                    input_device = i
        
        if input_device is None:
            print("No input device found!")
            return
        
        # Open stream with callback
        try:
            self.stream = self.p.open(
                format=FORMAT,
                channels=CHANNELS,
                rate=RATE,
                input=True,
                frames_per_buffer=CHUNK,
                input_device_index=input_device,
                stream_callback=self.audio_callback
            )
            print(f"Using device: {self.p.get_device_info_by_index(input_device)['name']}")
            self.stream.start_stream()
        except Exception as e:
            print(f"Error opening audio stream: {e}")
            self.stream = None
    
    def audio_callback(self, in_data, frame_count, time_info, status):
        """Audio callback function - runs in separate thread"""
        try:
            self.audio_queue.put(in_data, block=False)
        except queue.Full:
            # If queue is full, remove oldest item and add new one
            try:
                self.audio_queue.get_nowait()
                self.audio_queue.put(in_data, block=False)
            except queue.Empty:
                pass
        return (None, pyaudio.paContinue)
    
    def update_buffer(self):
        """Update the audio buffer with new data from queue"""
        updated = False
        while not self.audio_queue.empty():
            try:
                data = self.audio_queue.get_nowait()
                waveform = np.frombuffer(data, dtype=np.int16)
                
                # Roll buffer and add new data
                self.buffer = np.roll(self.buffer, -len(waveform))
                self.buffer[-len(waveform):] = waveform
                updated = True
                
            except queue.Empty:
                break
        return updated
    
    def update_plot(self, frame):
        """Update the plot with new data"""
        # Update buffer
        if not self.update_buffer():
            return self.line,
        
        # Update plot data
        self.line.set_ydata(self.buffer)
        
        # Calculate and display statistics
        rms = np.sqrt(np.mean(self.buffer.astype(np.float32)**2))
        max_amp = np.max(np.abs(self.buffer))
        
        self.ax.set_title(f'Real-time Audio Waveform (RMS: {rms:.0f}, Max: {max_amp})')
        
        # Dynamic y-axis scaling
        if max_amp > 1000:
            self.ax.set_ylim(-max_amp * 1.2, max_amp * 1.2)
        else:
            self.ax.set_ylim(-2000, 2000)  # Minimum range for quiet signals
        
        return self.line,
    
    def run(self):
        """Start the visualization"""
        print("Starting waveform visualization...")
        print("Make some noise to see the waveform!")
        print("Close the window or press Ctrl+C to stop.")
        
        try:
            # Start animation
            ani = animation.FuncAnimation(
                self.fig, 
                self.update_plot, 
                interval=50,  # 20 FPS
                blit=False,
                cache_frame_data=False
            )
            
            plt.show()
            
        except KeyboardInterrupt:
            print("Stopped by user")
        finally:
            self.cleanup()
    
    def cleanup(self):
        """Clean up resources"""
        print("Cleaning up...")
        if hasattr(self, 'stream') and self.stream:
            self.stream.stop_stream()
            self.stream.close()
        self.p.terminate()
        plt.close('all')

if __name__ == "__main__":
    try:
        visualizer = WaveformVisualizer()
        visualizer.run()
    except Exception as e:
        print(f"Error: {e}")
        import traceback
        traceback.print_exc()